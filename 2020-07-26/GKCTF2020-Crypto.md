## GKCTF2020——Crypto

### 1、小学生的密码学

题目描述：

```
e(x)=11x+6(mod26)

密文：welcylk

（flag为base64形式）
```

看到这道题，很容易知道这利用了仿射密码。

- 仿射密码

将密文利用[放射密码在线解密][https://aliyunvi.com/affine]转换为明文得到：`sorcery`

然后利用[在线工具][https://tool.oschina.net/encrypt?type=3]将明文转换为base64编码形式，得到：

```
c29yY2VyeQ==
```

则结果为`flag{c29yY2VyeQ==}`

### 2、汉字的秘密

题目描述：

> 你能看出汉字的奥秘吗？ 答案形式：flag{小写字母}

下载附件hanzi.docx，打开得到内容为：

>王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫

很明显，这是一个当铺加密，

```
# 当铺加密----笔画中有几个出头的就对应着数字几
# 例：王：6  夫：7  田：0  由：1  土：5
```

则原文转化得到：

``` 
69  74  62  67  118  83  72  77  86  55  71  57  82  57  64  63  51  107
```

然后考虑第二层加密，首先想到直接转换为ASCII码，得到

```
EJ >CvSHMV7G9R9@?3k 
```

用`flag{}`包住提交，错误，然后继续观察，发现了第二层就是一个变异凯撒加密，因为

```
ASCII码f  l  a  g  {  对应十进制为 70  76  65  71  123
与原文的十进制前5个分别相差：1，2，3，4，5
```

然后编写python脚本

```python
c = 'EJ>CvSHMV7G9R9@?3k'
j = 1
m = ''
for i in c:
	m += str(chr(ord(i)+j))
	j += 1
print(m)```
```

运行得到：`FLAG{YOU_ARE_GOOD}`，题目要求提交格式为`flag{小写字母}`,则最终结果为`flag{you_are_good}`

### 3、Babycrypto

题目描述：无

附件内容：`encode.txt`

``` 
# n:0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
# e:65537
# enc:1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
# p>>128<<128:0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
```

由附件我们可以明确知道`n`、`e`、`c`的值.

```
n = 22356763374676421464625378500213339933332772809897207920729779273423674391734609826525432054721219700275907299132471518921609327317193522567659631757746842030241874692914098354564311806192080734895649520789778880115460999713973202684541940857690744940359412410680906226760273075221532248260114209496048785258860756023841150910290983974843412361701517438220974722832625030127395031631696995777436058406987465592189873785392136925593708921923255186282515777996509326779993612528103615281644689464568237409082282767318227236298791238683706176542426759149262625349498709445342710799386836175120162674849965878446213480453
e = 65537
c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
```

试着去分解n，没有得到结果。然后只能从p下手，这是一个只有高位的p，利用`sagemath`将`p`的低位求出来。[在线运行](https://sagecell.sagemath.org/)。

```python
# 参考：https://github.com/Zui-Qing-Feng/RSA/blob/master/03.Factoring%20with%20high%20bits%20known%20Attack
n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
p_fake = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L

pbits = 1024  
kbits = 128
pbar = p_fake & (2^pbits-2^kbits)  
print ("upper %d bits (of %d bits) is given" % (pbits-kbits, pbits))
   
PR.<x> = PolynomialRing(Zmod(n))  
f = x + pbar  
x0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.3  
p = int(x0 + pbar)
print('p=',p)
```

![image-20200726184137539](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726184137.png)

得到的`p`的值。

```python
p = 160734387026849747944319274262095716650717626398118440194223452208652532694713113062084219512359968722796763029072117463281356654614167941930993838521563406258263299846297499190884495560744873319814150988520868951045961906000066805136724505347218275230562125457122462589576375152991358168492140057504650362880
```

然后就可知这是一个简单的RSA算法。编写如下脚本得到`flag{3d0914a1-1e97-4822-a745-c7e20c5179b9}`

```python
# encoding=utf-8
import gmpy2
import libnum

p = 160734387026849747944319274262095716650717626398118440194223452208652532694713113062084219512359968722796763029072117463281356654614167941930993838521563406258263299846297499190884495560744873319814150988520868951045961906000066805136724505347218275230562125457122462589576375152991358168492140057504650362880
e = 65537
c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
n = 22356763374676421464625378500213339933332772809897207920729779273423674391734609826525432054721219700275907299132471518921609327317193522567659631757746842030241874692914098354564311806192080734895649520789778880115460999713973202684541940857690744940359412410680906226760273075221532248260114209496048785258860756023841150910290983974843412361701517438220974722832625030127395031631696995777436058406987465592189873785392136925593708921923255186282515777996509326779993612528103615281644689464568237409082282767318227236298791238683706176542426759149262625349498709445342710799386836175120162674849965878446213480453

q = n/p
phi = (p-1)*(q-1)
d = gmpy2.invert(e,phi)
m = pow(c,d,n)
print libnum.n2s(m)
```

### 4、Backdoor

题目描述：

> p=k*M+(65537**a %M)

附件内容：`flag.enc`、`pub.pem`、`task.py`

```python
# flag.enc中内容
MDIxNDJhZjdjZTcwZmUwZGRhZTExNmJiN2U5NjI2MDI3NGVlOTI1MmE4Y2I1MjhlN2ZkZDI5ODA5YzJhNjAzMjcyN2MwNTUyNjEzM2FlNDYxMGVkOTQ0NTcyZmYxYWJmY2QwYjE3YWEyMmVmNDRhMg==
# pub.pem中内容
-----BEGIN PUBLIC KEY-----
MFMwDQYJKoZIhvcNAQEBBQADQgAwPwI4BXdHlrMB4cf0C0lFBWiLH94h9tX/zmNv
8WfYXjfXp7dJPjPBfUQXolyiSmcWMUzxhuFpltz8Z5sCAwEAAQ==
-----END PUBLIC KEY-----
# task.py中的内容
#!/usr/bin/python
from Crypto.Util.number import *
from Crypto.PublicKey import RSA
import gmpy2, binascii
import base64
from FLAG import flag

def rsa_encrypt(message):
    with open('./pub.pem' ,'r') as f:
        key = RSA.import_key(f.read())
    e = key.e
    n = key.n
    c = pow(bytes_to_long(flag), e, n)
 
    ciphertext = binascii.hexlify(long_to_bytes(c))
    return ciphertext

if __name__ == "__main__":
    text = base64.b64encode(rsa_encrypt(flag))
    with open('flag.enc','wb') as f:
        f.write(text)
```

解题步骤

- 根据以上内容，可知`flag.enc`是一个密文文件、`pub.pem`是一个公钥文件。然后使用`openssl`解密`pub.pem`中的参数。

```python
# 使用命令行
openssl rsa -pubin -text -modulus -in warmup -in pub.pem
# 得到的参数值：
e = 65537
n = 5774796B301E1C7F40B494505688B1FDE21F6D5FFCE636FF167D85E37D7A7B7493E33C17D4417A25CA24A6716314CF186E16996DCFC679B
```

![image-20200726142831590](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726142839.png)

- 将`n`值转换为十进制.

```python
n = 15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739
```

![image-20200726144228991](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726144409.png)

- [在线分解](http://factordb.com/)`n`得到`p`、`q`

```python
p = 3386619977051114637303328519173627165817832179845212640767197001941
q = 4582433561127855310805294456657993281782662645116543024537051682479
```

- 利用rsatool生产私钥文件。

```python
# 使用命令行
python3 rsatool.py -o private.pem -e 65537 -p 3386619977051114637303328519173627165817832179845212640767197001941 -q 4582433561127855310805294456657993281782662645116543024537051682479
# 得到私钥d的值
d = 11499569785990181290142150447540986299729313689398043794865222914751456271097337104622884992345120278959213140333860537563347711742153
```

![image-20200726145317973](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726145318.png)

![image-20200726151119973](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726151120.png)

- 用生成的`private.pem`解密`flag.enc`。

```
# 使用命令行
openssl rsautl -decrypt -in flag.enc -inkey private.pem
```

![image-20200726154030290](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726154034.png)

没有得到`flag`且报错：可能是不是使用的原密文作为`flag.enc`中的内容导致。

- 然后编写如下python脚本，运行得到结果为`flag{760958c9-cca9-458b-9cbe-ea07aa1668e4}`

```python
# encoding=utf-8

from Crypto.Util.number import*

e = 65537
p = 3386619977051114637303328519173627165817832179845212640767197001941
q = 4582433561127855310805294456657993281782662645116543024537051682479
n = 15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739
d = 11499569785990181290142150447540986299729313689398043794865222914751456271097337104622884992345120278959213140333860537563347711742153
with open('/home/lt/桌面/flag.enc',"rb") as f:
	c = int(f.read().decode('base64'),16)
m = pow(c,d,n)
flag = long_to_bytes(m)

print flag
```

![image-20200726153406555](https://raw.githubusercontent.com/XiDuoEr/typroa-pictures/master/20200726153406.png)